"""
Generate TTS audio for all missing words across all wordbooks.

Reads the missing word list from all_missing_audio.txt (generated by scanning
all registered wordbooks against the audio directory).

Uses Google Cloud TTS Chirp 3 HD (Zephyr) voice - same as existing audio files.
Output: words/tts_delivery/audio/{word}.wav

Usage:
    # First, regenerate the missing word list:
    node -e "
    global.WORDBOOK_REGISTRY={};
    global.registerWordbook=function(i,c){WORDBOOK_REGISTRY[i]=c};
    require('./oxford_vocabulary.js');
    var fs=require('fs');
    fs.readdirSync('./wordbooks').filter(f=>f.endsWith('.js')).forEach(f=>require('./wordbooks/'+f));
    var audioDir='words/tts_delivery/audio';
    var audioFiles=new Set(fs.readdirSync(audioDir).map(f=>f.replace('.wav','')));
    var allMissing=new Set();
    Object.keys(WORDBOOK_REGISTRY).forEach(id=>{
      var wb=WORDBOOK_REGISTRY[id];
      Object.keys(wb.levels).forEach(lv=>{
        wb.levels[lv].words.forEach(w=>{
          if(audioFiles.has(w.word)===false) allMissing.add(w.word);
        });
      });
    });
    console.log(Array.from(allMissing).sort().join('\\n'));
    " > words/all_missing_audio.txt

    # Then generate audio:
    python words/generate_missing_audio.py

    # Or do a dry run first:
    python words/generate_missing_audio.py --dry-run
"""

import os
import sys
import argparse
import json
from google.cloud import texttospeech
from google.api_core import client_options

# --- Configuration ---
LANGUAGE_CODE = 'en-US'
TARGET_VOICE_NAME = 'en-US-Chirp3-HD-Zephyr'
GOOGLE_CLOUD_PROJECT_ID = 'gen-lang-client-0153103557'

# Fix Windows console encoding for progress output
if sys.platform == 'win32' and hasattr(sys.stdout, 'reconfigure'):
    sys.stdout.reconfigure(encoding='utf-8', errors='replace')


def get_text_to_speech_client():
    """Initializes the Text-to-Speech client with explicit quota project."""
    try:
        options = client_options.ClientOptions(quota_project_id=GOOGLE_CLOUD_PROJECT_ID)
        return texttospeech.TextToSpeechClient(client_options=options)
    except Exception as e:
        import traceback
        traceback.print_exc()
        print(f"Error initializing Google Cloud TTS Client: {e}")
        print("Ensure you have authenticated using: gcloud auth application-default login")
        return None


def synthesize_text(client, text, voice_name, output_path):
    """Synthesizes speech using SSML with 300ms padding to prevent audio cutoff."""
    ssml_text = f'<speak>{text}<break time="300ms"/></speak>'
    input_text = texttospeech.SynthesisInput(ssml=ssml_text)

    voice = texttospeech.VoiceSelectionParams(
        language_code=LANGUAGE_CODE,
        name=voice_name
    )
    audio_config = texttospeech.AudioConfig(
        audio_encoding=texttospeech.AudioEncoding.LINEAR16
    )

    try:
        response = client.synthesize_speech(
            request={"input": input_text, "voice": voice, "audio_config": audio_config}
        )
        with open(output_path, "wb") as out:
            out.write(response.audio_content)
        return True
    except Exception as e:
        print(f"  ERROR synthesizing '{text}': {e}")
        return False


def main():
    parser = argparse.ArgumentParser(description='Generate TTS audio for missing words')
    parser.add_argument('--dry-run', action='store_true', help='List words without generating audio')
    parser.add_argument('--input', default=None, help='Input file (default: words/all_missing_audio.txt)')
    args = parser.parse_args()

    # Setup paths
    base_dir = os.path.dirname(os.path.abspath(__file__))
    audio_dir = os.path.join(base_dir, 'tts_delivery', 'audio')
    input_file = args.input or os.path.join(base_dir, 'all_missing_audio.txt')

    if not os.path.exists(audio_dir):
        os.makedirs(audio_dir)

    # Load missing words
    if not os.path.exists(input_file):
        print(f"Error: {input_file} not found.")
        print("Generate it first with the Node.js command in the script header.")
        return

    with open(input_file, 'r', encoding='utf-8') as f:
        words = [line.strip() for line in f if line.strip() and not line.startswith('#')]

    # Skip words that already have audio (in case of partial re-runs)
    existing_audio = set()
    if os.path.exists(audio_dir):
        existing_audio = {f.replace('.wav', '') for f in os.listdir(audio_dir) if f.endswith('.wav')}

    to_generate = [w for w in words if w not in existing_audio]
    already_done = len(words) - len(to_generate)

    print(f"=== Missing Audio Generator ===")
    print(f"Total missing words: {len(words)}")
    print(f"Already have audio:  {already_done}")
    print(f"Need to generate:    {len(to_generate)}")
    print(f"Output directory:    {audio_dir}")
    print()

    if not to_generate:
        print("All words already have audio! Nothing to do.")
        return

    if args.dry_run:
        print("--- DRY RUN: Words to generate ---")
        for i, w in enumerate(to_generate, 1):
            print(f"  {i:4d}. {w}")
        print(f"\nTotal: {len(to_generate)} words")
        return

    # Init TTS client
    client = get_text_to_speech_client()
    if not client:
        return

    # Generate audio
    success = 0
    failed = []
    total = len(to_generate)

    print(f"Starting TTS generation for {total} words...")
    print(f"Voice: {TARGET_VOICE_NAME}")
    print(f"Format: WAV (LINEAR16)")
    print()

    for i, word in enumerate(to_generate, 1):
        filename = f"{word}.wav"
        output_path = os.path.join(audio_dir, filename)

        progress = f"[{i}/{total}]"
        print(f"{progress} Generating: {word}...", end=' ', flush=True)

        if synthesize_text(client, word, TARGET_VOICE_NAME, output_path):
            success += 1
            size_kb = os.path.getsize(output_path) / 1024
            print(f"OK ({size_kb:.1f} KB)")
        else:
            failed.append(word)
            print("FAILED")

    # Summary
    print()
    print(f"=== Generation Complete ===")
    print(f"Success: {success}/{total}")
    if failed:
        print(f"Failed:  {len(failed)} words:")
        for w in failed:
            print(f"  - {w}")
        # Save failed list for retry
        failed_file = os.path.join(base_dir, 'tts_failed.txt')
        with open(failed_file, 'w', encoding='utf-8') as f:
            f.write('\n'.join(failed) + '\n')
        print(f"Failed words saved to: {failed_file}")
    else:
        print("All words generated successfully!")


if __name__ == "__main__":
    main()
